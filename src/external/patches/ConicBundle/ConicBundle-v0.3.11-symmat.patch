--- ConicBundle-v0.3.11.src-patched-orig/Matrix/symmat.hxx	2017-05-04 17:02:59.000000000 -0400
+++ ConicBundle-v0.3.11.src/Matrix/symmat.hxx	2017-05-04 18:57:06.000000000 -0400
@@ -53,24 +53,41 @@ namespace CH_Matrix_Classes {
 
   /** @brief %Matrix class of symmetric matrices with real values of type #Real
 
-      Internally a symmetric matrix of size nr x nr is stored in a one dimensional 
-      array of ::Real variables, the elements of the lower triangle 
+      Internally a symmetric matrix of size nr x nr is stored in a one dimensional
+      array of ::Real variables, the elements of the lower triangle
       are arranged in columnwise order (a11,a21,...,anr1,a22,a32,...).
-      
-      Any matrix element can be indexed by (i,j) or directly by the one dimensional 
-      index (i+j*nr). The latter view directly corresponds to the vec() operator 
-      often used in the linear algebra literature, i.e., the matrix is 
+
+      Any matrix element can be indexed by (i,j) or directly by the one dimensional
+      index (i+j*nr). The latter view directly corresponds to the vec() operator
+      often used in the linear algebra literature, i.e., the matrix is
       transformed to a vector by stacking the columns on top of each other.
 
-      NOTE: Any change of A(i,j) also changes A(j,i) as both variables are identical! 
+      NOTE: Any change of A(i,j) also changes A(j,i) as both variables are identical!
 
    */
+
+// The class below declares these as 'friend' functions,
+// but simultaneously attempts to provide default arguments for them.
+// That's not allowed, but we can declare them here first, with their default arguments.
+// See: http://stackoverflow.com/questions/23333949/the-correct-way-to-define-default-argument-for-a-friend-function-in-c
+class Symmatrix;
+inline Symmatrix& xbpeya(Symmatrix& x,const Symmatrix& y,Real alpha=1.,Real beta=0.);
+inline Symmatrix& xeyapzb(Symmatrix& x,const Symmatrix& y,const Symmatrix& z,Real alpha=1.,Real beta=1.);
+Symmatrix& rankadd(const Matrix& A,Symmatrix& C,Real alpha=1.,Real beta=0.,int trans=0);
+Symmatrix& rank2add(const Matrix& A, const Matrix& B, Symmatrix& C,Real alpha=1.,Real beta=0.,int trans=0);
+Matrix& genmult(const Symmatrix& A,const Matrix& B,Matrix& C,Real alpha=1., Real beta=0., int btrans=0);
+Matrix& genmult(const Matrix& A,const Symmatrix& B,Matrix& C,Real alpha=1., Real beta=0., int atrans=0);
+Matrix& genmult(const Symmatrix& A,const Sparsemat& B,Matrix& C,Real alpha=1.,Real beta=0., int btrans=0);
+Matrix& genmult(const Sparsemat& A,const Symmatrix& B,Matrix& C,Real alpha=1.,Real beta=0., int atrans=0);
+Symmatrix& rankadd(const Sparsemat& A,Symmatrix& C,Real alpha=1.,Real beta=0.,int trans=0);
+Symmatrix& rank2add(const Sparsemat& A,const Matrix& B,Symmatrix& C,Real alpha=1.,Real beta=0.,int trans=0);
+
 class Symmatrix: protected Memarrayuser
 {
-    friend class Matrix; 
+    friend class Matrix;
     friend class Sparsesym;
     friend class Sparsemat;
-    
+
 private:
 
     static const Mtype mtype;   ///< used for MatrixError templates (runtime type information was not yet existing)
@@ -81,8 +98,8 @@ private:
     bool is_init;   ///< flag whether memory is initialized, it is only used if CONICBUNDLE_DEBUG is defined
 
     /// initialize the matrix to a 0x0 matrix without storage
-    inline void init_to_zero();        
-    
+    inline void init_to_zero();
+
     /// a subroutine needed internally for eigenvalue computations (eigval.cxx)
     Integer tred2(Integer nm, Integer n, Real *a, Real *d, Real *e, Real *z) const;
     /// a subroutine needed internally for eigenvalue computations (eigval.cxx)
@@ -100,30 +117,30 @@ public:
   //@{
 
   /// empty matrix
-  inline Symmatrix(); 
+  inline Symmatrix();
   /// copy constructor, *this=d*A
   inline Symmatrix(const Symmatrix& A,double d=1.);
   /** @brief generate a matrix of size nr x nr but WITHOUT initializing the memory
-      
-      If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use 
-      set_init() via matrix.set_init(true) in order to avoid warnings concerning improper 
+
+      If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use
+      set_init() via matrix.set_init(true) in order to avoid warnings concerning improper
       initialization
-  */ 
+  */
   inline Symmatrix(Integer nr);
   /// generate a matrix of size nr x nr initializing all elements to the value d
-  inline Symmatrix(Integer nr,Real d);   
+  inline Symmatrix(Integer nr,Real d);
   /// generate a matrix of size nr x nr initializing the elements from the (one dimensional) array dp, which must have the elements arranged consecutively in internal order
   inline Symmatrix(Integer nr,Real* dp);
   ///
-  inline ~Symmatrix();                   
-  
+  inline ~Symmatrix();
+
 #if (CONICBUNDLE_DEBUG>=1)
   /// after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG is undefined)
   void set_init(bool i){is_init=i;}
    /// returns true if the matrix has been declared initialized (not needed if CONICBUNDLE_DEBUG is undefined)
  int get_init() const {return is_init;}
-#else 
-  /// after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG is undefined) 
+#else
+  /// after external initialization, call matrix.set_init(true) (not needed if CONICBUNDLE_DEBUG is undefined)
   void set_init(bool /* i */){}
   /// returns true if the matrix has been declared initialized (not needed if CONICBUNDLE_DEBUG is undefined)
   bool get_init() const {return true;}
@@ -141,13 +158,13 @@ public:
   inline Symmatrix& init(Integer nr,Real d);
   /// generate a matrix of size nr x nc initializing the elements from the (one dimensional) array dp which must have the elements arranged consecutively in internal order
   inline Symmatrix& init(Integer nr,Real* dp);
-    
+
   /** @brief resize the matrix to nr x nr elements but WITHOUT initializing the memory
-      
-      If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use 
-      set_init() via matrix.set_init(true) in order to avoid warnings concerning improper 
+
+      If initializing the memory externally and CONICBUNDLE_DEBUG is defined, please use
+      set_init() via matrix.set_init(true) in order to avoid warnings concerning improper
       initialization
-  */ 
+  */
   void newsize(Integer n);      //resize matrix without Initialization
 
 
@@ -162,8 +179,8 @@ public:
   /// (*this)=d*(A+transpose(A))/2.
   inline Symmatrix(const Indexmatrix&,double d=1.);
   /// (*this)=d*A
-  inline Symmatrix(const Sparsesym& A,Real d=1.); 
-  
+  inline Symmatrix(const Sparsesym& A,Real d=1.);
+
   //@}
 
   //----------------------------------------------------
@@ -185,12 +202,12 @@ public:
 
   /// returns the column dimension
   Integer coldim() const {return nr;}
-  
+
   /// returns the type of the matrix, MTsymmetric
   Mtype get_mtype() const {return mtype;}
 
   //@}
-    
+
 
   //--------------------------------
   //----  Indexing and Submatrices
@@ -211,12 +228,12 @@ public:
 
   /// returns value of element (i) of the matrix if regarded as vector of stacked columns [element (i%rowdim, i/rowdim)]
   inline Real operator()(Integer i) const;
-  
-  /// returns column i copied to a new Matrix 
-  Matrix col(Integer i) const;     
-  /// returns row i copied to a new ;atrix 
-  Matrix row(Integer i) const;       
- 
+
+  /// returns column i copied to a new Matrix
+  Matrix col(Integer i) const;
+  /// returns row i copied to a new ;atrix
+  Matrix row(Integer i) const;
+
   /// returns the current address of the internal value array; use cautiously, do not use delete!
    Real* get_store() {return m;}   //use cautiously, do not use delete!
   /// returns the current address of the internal value array; use cautiously!
@@ -229,9 +246,9 @@ public:
    */
   //@{
 
-  /// returns a column vector v consisting of the elements v(i)=(*this)(i,i), 0<=i<row dimension 
+  /// returns a column vector v consisting of the elements v(i)=(*this)(i,i), 0<=i<row dimension
   friend Matrix diag(const Symmatrix& A);    //=(A(1,1),A(2,2),...)^t
-  /// returns a symmetric diagonal matrix S of order A.dim() with vec(A) on the diagonal, i.e., S(i,i)=A(i) for all i and S(i,j)=0 for i!=j 
+  /// returns a symmetric diagonal matrix S of order A.dim() with vec(A) on the diagonal, i.e., S(i,i)=A(i) for all i and S(i,j)=0 for i!=j
   friend Symmatrix Diag(const Matrix& A);    //vec(A) on the diagonal
 
   /// swap the content of the two matrices A and B (involves no copying)
@@ -249,10 +266,10 @@ public:
 
   ///sets *this=d*A and returns *this
   Symmatrix& xeya(const Symmatrix& A,Real d=1.);   //*this=d*A
-  ///sets *this+=d*A and returns *this  
+  ///sets *this+=d*A and returns *this
   Symmatrix& xpeya(const Symmatrix& A,Real d=1.);  //*this+=d*A;
 
-    
+
   //@}
 
   /** @name BLAS-like Routines (Friends)
@@ -260,27 +277,23 @@ public:
   //@{
 
   /// returns C=beta*C+alpha* A*A^T, where A may be transposed. If beta==0. then C is initiliazed to the correct size.
-  friend Symmatrix& rankadd(const Matrix& A,Symmatrix& C,
-			    Real alpha=1.,Real beta=0.,int trans=0);
+  friend Symmatrix& rankadd(const Matrix& A,Symmatrix& C,Real alpha,Real beta,int trans);
   /// returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size.
-  friend Symmatrix& rank2add(const Matrix& A, const Matrix& B, Symmatrix& C,
-			     Real alpha=1.,Real beta=0.,int trans=0);
-   
-  
+  friend Symmatrix& rank2add(const Matrix& A, const Matrix& B, Symmatrix& C,Real alpha,Real beta,int trans);
+
+
   ///returns x= alpha*y+beta*x; if beta==0. then x is initialized to the correct size
-  friend inline Symmatrix& xbpeya(Symmatrix& x,const Symmatrix& y,Real alpha=1.,Real beta=0.);
-  
+  friend inline Symmatrix& xbpeya(Symmatrix& x,const Symmatrix& y,Real alpha,Real beta);
+
 
   ///returns x= alpha*y+beta*z; x is initialized to the correct size
-  friend inline Symmatrix& xeyapzb(Symmatrix& x,const Symmatrix& y,const Symmatrix& z,Real alpha=1.,Real beta=1.);
-  
+  friend inline Symmatrix& xeyapzb(Symmatrix& x,const Symmatrix& y,const Symmatrix& z,Real alpha,Real beta);
+
   ///returns C=beta*C+alpha*A*B, where B may be transposed; C must not be equal to B; if beta==0. then C is initialized to the correct size
-  friend Matrix& genmult(const Symmatrix& A,const Matrix& B,Matrix& C,
-			 Real alpha=1., Real beta=0., int btrans=0);
+  friend Matrix& genmult(const Symmatrix& A,const Matrix& B,Matrix& C,Real alpha, Real beta, int btrans);
 
   ///returns C=beta*C+alpha*A*B, where A may be transposed; C must not be equal to A; if beta==0. then C is initialized to the correct size
-  friend Matrix& genmult(const Matrix& A,const Symmatrix& B,Matrix& C,
-			 Real alpha=1., Real beta=0., int atrans=0);
+  friend Matrix& genmult(const Matrix& A,const Symmatrix& B,Matrix& C,Real alpha, Real beta, int atrans);
 
   //@}
 
@@ -293,7 +306,7 @@ public:
   //@{
 
   ///
-  inline Symmatrix& operator=(const Symmatrix &A); 
+  inline Symmatrix& operator=(const Symmatrix &A);
   ///
   inline Symmatrix& operator+=(const Symmatrix &A);
   ///
@@ -301,9 +314,9 @@ public:
   /// ATTENTION: this is redefined as the Hadamard product, (*this)(i,j)=(*this)(i,j)*A(i,j) for all i<=j
   inline Symmatrix& operator%=(const Symmatrix &A);  //Hadamard product
   ///
-  inline Symmatrix operator-() const; 
-  
-  /// 
+  inline Symmatrix operator-() const;
+
+  ///
   inline Symmatrix& operator*=(Real d);
   /// ATTENTION: d is NOT checked for 0
   inline Symmatrix& operator/=(Real d);
@@ -312,8 +325,8 @@ public:
   /// sets (*this)(i,j)-=d for all i<=j
   inline Symmatrix& operator-=(Real d);
 
-  ///transposes itself (at almost no cost)  
-  Symmatrix& transpose(){return *this;} 
+  ///transposes itself (at almost no cost)
+  Symmatrix& transpose(){return *this;}
 
   //@}
 
@@ -321,16 +334,16 @@ public:
    */
   //@{
 
-  /// 
+  ///
   friend inline Matrix operator*(const Symmatrix &A,const Symmatrix &B);
-  /// ATTENTION: this is redefined as the Hadamard product and sets (i,j)=A(i,j)*B(i,j) for all i<=j  
+  /// ATTENTION: this is redefined as the Hadamard product and sets (i,j)=A(i,j)*B(i,j) for all i<=j
   friend inline Symmatrix operator%(const Symmatrix &A,const Symmatrix &B);
   ///
   friend inline Symmatrix operator+(const Symmatrix &A,const Symmatrix &B);
   ///
   friend inline Symmatrix operator-(const Symmatrix &A,const Symmatrix &B);
   ///
-  friend inline Matrix operator*(const Symmatrix &A,const Matrix &B); 
+  friend inline Matrix operator*(const Symmatrix &A,const Matrix &B);
   ///
   friend inline Matrix operator*(const Matrix &A,const Symmatrix &B);
   ///
@@ -365,7 +378,7 @@ public:
   //------------------------------------------
   //----  Connections to other Matrix Classes
   //------------------------------------------
-  
+
   /** @name Connections to other Classes (Members)
    */
   //@{
@@ -378,16 +391,16 @@ public:
   Symmatrix& xeya(const Indexmatrix& A,Real d=1.);   //*this=d*A
   ///sets *this+=d*(A+transpose(A))/2. and returns *this
   Symmatrix& xpeya(const Indexmatrix& A,Real d=1.);  //*this+=d*A;
-  ///sets *this=d*A and returns *this 
+  ///sets *this=d*A and returns *this
   Symmatrix& xeya(const Sparsesym& A,Real d=1.);   //*this=d*A
-  ///sets *this+=d*A and returns *this 
+  ///sets *this+=d*A and returns *this
   Symmatrix& xpeya(const Sparsesym& A,Real d=1.);  //*this+=d*A;
 
   ///sets *this(i,j), i<=j to the upper triangle of the matrix product d*transpose(A)*B
   Symmatrix& xetriu_yza(const Matrix& A,const Matrix& B,Real d=1.);
   ///adds to *this(i,j), i<=j the upper triangle of the matrix product d*transpose(A)*B
   Symmatrix& xpetriu_yza(const Matrix& A,const Matrix& B,Real d=1.);
-  ///sets *this(i,j), i<=j to the upper triangle of the matrix product d*transpose(A)*B  
+  ///sets *this(i,j), i<=j to the upper triangle of the matrix product d*transpose(A)*B
   Symmatrix& xetriu_yza(const Sparsemat& A,const Matrix& B,Real d=1.);
   ///adds to *this(i,j), i<=j the upper triangle of the matrix product d*transpose(A)*B
   Symmatrix& xpetriu_yza(const Sparsemat& A,const Matrix& B,Real d=1.);
@@ -406,23 +419,19 @@ public:
   //@{
 
   ///returns C=beta*C+alpha*A*B, where B may be transposed; if beta==0. then C is initialized to the correct size
-  friend Matrix& genmult(const Symmatrix& A,const Sparsemat& B,Matrix& C,
-			 Real alpha=1.,Real beta=0., int btrans=0);
+  friend Matrix& genmult(const Symmatrix& A,const Sparsemat& B,Matrix& C,Real alpha,Real beta, int btrans);
 
   ///returns C=beta*C+alpha*A*B, where A may be transposed; if beta==0. then C is initialized to the correct size
-  friend Matrix& genmult(const Sparsemat& A,const Symmatrix& B,Matrix& C,
-                           Real alpha=1.,Real beta=0., int atrans=0);
+  friend Matrix& genmult(const Sparsemat& A,const Symmatrix& B,Matrix& C,Real alpha,Real beta, int atrans);
 
   /// returns C=beta*C+alpha* A*A^T, where A may be transposed; if beta==0. then C is initialized to the correct size
-  friend Symmatrix& rankadd(const Sparsemat& A,Symmatrix& C,
-			    Real alpha=1.,Real beta=0.,int trans=0);
-    
+  friend Symmatrix& rankadd(const Sparsemat& A,Symmatrix& C,Real alpha,Real beta,int trans);
+
   /// returns C=beta*C+alpha*(A*B^T+B*A^T)/2 [or for transposed (A^T*B+B^T*A)/2]. If beta==0. then C is initiliazed to the correct size.
-  friend Symmatrix& rank2add(const Sparsemat& A,const Matrix& B,Symmatrix& C,
-			     Real alpha=1.,Real beta=0.,int trans=0);
+  friend Symmatrix& rank2add(const Sparsemat& A,const Matrix& B,Symmatrix& C,Real alpha,Real beta,int trans);
 
    //@}
-   
+
   //------------------------------
   //----  Elementwise Operations
   //------------------------------
@@ -432,7 +441,7 @@ public:
    */
   //@{
 
-  friend Symmatrix abs(const Symmatrix& A);                 
+  friend Symmatrix abs(const Symmatrix& A);
 
   //@}
 
@@ -449,34 +458,34 @@ public:
 
   //----- LDL Factorization (for positive definite matrices, no pivots so far!)
   /// computes LDLfactorization (implemented only for positive definite matrices so far, no pivoting), (*this) is overwritten by the factorization; returns 1 if diagonal elements go below tol
-  int LDLfactor(Real tol=1e-10);     
-  /// computes, after LDLfactor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero  
+  int LDLfactor(Real tol=1e-10);
+  /// computes, after LDLfactor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero
   int LDLsolve(Matrix& x) const;      //call LDLfactor before using LDLsolve!
-  /// computes, after LDLfactor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero  
+  /// computes, after LDLfactor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero
   int LDLinverse(Symmatrix& S) const; //call LDLfactor before using LDLinverse!
-    
+
   //----- Cholesky Factorization with pivoting
   /// computes the Cholesky factorization, for positive definite matrices only, (*this) is overwritten by the factorization; there is no pivoting; returns 1 if diagonal elements go below tol
   int Chol_factor(Real tol=1e-10); //stores fact. in *this
-  /// computes, after Chol_factor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero  
+  /// computes, after Chol_factor was executed succesfully, the solution to (*old_this)x=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero
   int Chol_solve(Matrix& x) const; //call _factor before
-  /// computes, after Chol_factor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero  
+  /// computes, after Chol_factor was executed succesfully, the inverse to (*old_this) and stores it in S (numerically not too wise); always returns 0; NOTE: there is NO check against division by zero
   int Chol_inverse(Symmatrix& S) const; // --- " ---
-  /// computes, after Chol_factor into LL^T was executed succesfully, the solution to Lx=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero  
+  /// computes, after Chol_factor into LL^T was executed succesfully, the solution to Lx=rhs; rhs is overwritten by the solution; always returns 0; NOTE: there is NO check against division by zero
   int Chol_Lsolve(Matrix& rhs) const; // --- " ---, solve only Ly=x
   /// computes, after Chol_factor into LL^T was executed succesfully, L^{-1}SL^{-T} overwriting S
   int Chol_scaleLi(Symmatrix& S) const;
-  /// computes, after Chol_factor into LL^T was executed succesfully, the solution to L^Trhs, overwriting rhs by the solution; always returns 0;  
-  int Chol_Ltmult(Matrix& rhs) const; 
+  /// computes, after Chol_factor into LL^T was executed succesfully, the solution to L^Trhs, overwriting rhs by the solution; always returns 0;
+  int Chol_Ltmult(Matrix& rhs) const;
   /// computes the Cholesky factorization with pivoting, for positive semidefinite matrices only, (*this) is overwritten by the factorization; on termination piv.dim() is the number of positive pivots>=tol; returns 1 if negative diagonal element is encountered during computations, 0 otherwise.
   int Chol_factor(Indexmatrix &piv, Real tol=1e-10); //stores fact. in *this
-  /// computes, after Chol_factor(Indexmatrix&,Real) with pivoting was executed succesfully, the solution to (*old_this)*x=rhs(piv); rhs is overwritten by the solution arranged in original unpermuted order; always returns 0; NOTE: there is NO check against division by zero  
+  /// computes, after Chol_factor(Indexmatrix&,Real) with pivoting was executed succesfully, the solution to (*old_this)*x=rhs(piv); rhs is overwritten by the solution arranged in original unpermuted order; always returns 0; NOTE: there is NO check against division by zero
   int Chol_solve(Matrix& x,const Indexmatrix& piv) const; //call _factor before
-  /// computes, after Chol_factor(Indexmatrix&,Real) with pivoting was executed succesfully, the inverse to (*old_this) and stores it in S (the pivoting permutation is undone in S); NOTE: there is NO check against division by zero  
+  /// computes, after Chol_factor(Indexmatrix&,Real) with pivoting was executed succesfully, the inverse to (*old_this) and stores it in S (the pivoting permutation is undone in S); NOTE: there is NO check against division by zero
   int Chol_inverse(Symmatrix& S,const Indexmatrix & piv) const; // --- " ---
 
   //----- Eigenvalue decomposition
-  /// computes an eigenvalue decomposition P*Diag(d)*tranpose(P)=(*this) by symmetric QR; returns 0 on success, 
+  /// computes an eigenvalue decomposition P*Diag(d)*tranpose(P)=(*this) by symmetric QR; returns 0 on success,
   Integer eig(Matrix& P,Matrix& d,bool sort_non_decreasingly=true) const;
   //if return value ==0 then P contains eigenvectors as columns
   //and d is a column vector containing the eigenvalues.
@@ -489,13 +498,13 @@ public:
 
   /// returns the sum of the diagonal elements A(i,i) over all i
   friend Real trace(const Symmatrix& A);                  //=sum(diag(A))
-  ///returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j 
+  ///returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j
   friend Real ip(const Symmatrix& A, const Symmatrix& B); //=trace(B^t*A)
-  ///returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j 
+  ///returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j
   friend Real ip(const Matrix& A, const Symmatrix& B);    //=trace(B^t*A)
-  ///returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j 
+  ///returns the usual inner product of A and B, i.e., the sum of A(i,j)*B(i,j) over all i,j
   friend Real ip(const Symmatrix& A, const Matrix& B);    //=trace(B^t*A)
-  ///returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j 
+  ///returns the Frobenius norm of A, i.e., the square root of the sum of A(i,j)*A(i,j) over all i,j
   friend inline Real norm2(const Symmatrix& A); //{return sqrt(ip(A,A));}
 
   ///returns a row vector holding the sum over all rows, i.e., (1 1 ... 1)*A
@@ -504,15 +513,15 @@ public:
   friend Matrix sumcols(const Symmatrix& A); //=A*(1 1 ... 1)^t
   ///returns the sum over all elements of A, i.e., (1 1 ... 1)*A*(1 1 ... 1)^T
   friend Real sum(const Symmatrix& A);       //=(1 1 ... 1)*A*(1 1 ... 1)^t
-  
+
   //---- svec and skron
   /// the symmetric vec operator, stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; i.e., it sets v=svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]'
-  friend void svec(const Symmatrix& A,Matrix& v); 
+  friend void svec(const Symmatrix& A,Matrix& v);
   /// the symmetric vec operator, stacks the lower triangle of A to a n*(n+1)/2 vector with the same norm2 as A; i.e., it returns svec(A)=[a11,sqrt(2)a12,...,sqrt(2)a1n,a22,...,sqrt(2)a(n-1,n),ann]'
   friend inline Matrix svec(const Symmatrix& A);
   /// the inverse operator to svec, reconstructs the symmetric matrix A form the vector v
   friend void sveci(const Matrix& v,Symmatrix& A);
-  
+
   /// the symmetric Kronecker product, defined via (A skron B)svec(C)=(BCA'+ACB')/2; returns the symmetric matrix (A skron B)
   friend inline Symmatrix skron(const Symmatrix& A,const Symmatrix& B);
   /// the symmetric Kronecker product, defined via (A skron B)svec(C)=(BCA'+ACB')/2; sets S=(A skron B)
@@ -572,8 +581,8 @@ public:
 
   ///input format (nr and nc are ::Integer values, all others ::Real values): \n nr nc \\n A(1,1) A(1,2) ... A(1,nc) \\n A(2,1) ... A(nr,nc) \\n
   friend std::istream& operator>>(std::istream& i,Symmatrix &A);
-  
-  //@}  
+
+  //@}
 
 
 };
@@ -634,15 +643,15 @@ inline void Symmatrix::init_to_zero()
 #if (CONICBUNDLE_DEBUG>=1)
  is_init=true;
 #endif
-} 
+}
 
-inline Symmatrix& Symmatrix::init(const Symmatrix& A,double d) 
+inline Symmatrix& Symmatrix::init(const Symmatrix& A,double d)
 { return xeya(A,d); }
 
-inline Symmatrix& Symmatrix::init(const Matrix& A,double d) 
+inline Symmatrix& Symmatrix::init(const Matrix& A,double d)
 { return xeya(A,d); }
 
-inline Symmatrix& Symmatrix::init(const Indexmatrix& A,double d) 
+inline Symmatrix& Symmatrix::init(const Indexmatrix& A,double d)
 { return xeya(A,d); }
 
 inline Symmatrix& Symmatrix::init(Integer inr,Real d)
@@ -661,11 +670,11 @@ inline Symmatrix& Symmatrix::init(Intege
  return *this;
 }
 
-inline Symmatrix::Symmatrix() 
+inline Symmatrix::Symmatrix()
 { init_to_zero(); }
-    
+
 inline Symmatrix::Symmatrix(const Symmatrix& A,double d):Memarrayuser()
-{init_to_zero(); xeya(A,d);}     
+{init_to_zero(); xeya(A,d);}
 
 inline Symmatrix::Symmatrix(const Matrix &M,double d)
 { init_to_zero(); xeya(M,d); }
@@ -685,7 +694,7 @@ inline Symmatrix::Symmatrix(Integer i,Re
 inline Symmatrix::~Symmatrix()
 {memarray->free(m);}
 
-inline Real& Symmatrix::operator()(Integer i,Integer j) 
+inline Real& Symmatrix::operator()(Integer i,Integer j)
 {
  chk_range(i,j,nr,nr);
  if (j>=i) return m[((i*((nr<<1)-(i+1)))>>1)+j];
@@ -718,7 +727,7 @@ inline Real Symmatrix::operator()(Intege
 }
 
 inline void swap(Symmatrix &A,Symmatrix &B)
-{ 
+{
  Real *hm=A.m;A.m=B.m;B.m=hm;
  Integer hi=A.nr;A.nr=B.nr;B.nr=hi;
  hi=A.mem_dim;A.mem_dim=B.mem_dim;B.mem_dim=hi;
@@ -753,16 +762,16 @@ inline Symmatrix& xeyapzb(Symmatrix& x,c
 	      x.get_store(),y.get_store(),z.get_store(),alpha,beta);
   return x;
 }
-  
-inline Symmatrix& Symmatrix::operator=(const Symmatrix &A)   
+
+inline Symmatrix& Symmatrix::operator=(const Symmatrix &A)
     {return xeya(A);}
-inline Symmatrix& Symmatrix::operator+=(const Symmatrix &A) 
+inline Symmatrix& Symmatrix::operator+=(const Symmatrix &A)
     {return xpeya(A);}
-inline Symmatrix& Symmatrix::operator-=(const Symmatrix &A) 
+inline Symmatrix& Symmatrix::operator-=(const Symmatrix &A)
     {return xpeya(A,-1.);}
 inline Symmatrix& Symmatrix::operator%=(const Symmatrix &A)
-    { chk_add(*this,A); mat_xhadey((nr*(nr+1))/2,m,A.m); return *this; } 
-inline Symmatrix  Symmatrix::operator-() const    
+    { chk_add(*this,A); mat_xhadey((nr*(nr+1))/2,m,A.m); return *this; }
+inline Symmatrix  Symmatrix::operator-() const
     {return Symmatrix(*this,-1.);}
 
 inline Symmatrix& Symmatrix::operator*=(Real d)
@@ -776,13 +785,13 @@ inline Symmatrix& Symmatrix::operator-=(
 
 inline Matrix operator*(const Symmatrix &A,const Symmatrix &B)
     {Matrix C;return genmult(Matrix(A),B,C);}
-inline Symmatrix operator%(const Symmatrix &A,const Symmatrix &B) 
+inline Symmatrix operator%(const Symmatrix &A,const Symmatrix &B)
     {Symmatrix C(A);C%=B;return C;}
-inline Symmatrix operator+(const Symmatrix &A,const Symmatrix &B) 
+inline Symmatrix operator+(const Symmatrix &A,const Symmatrix &B)
     {Symmatrix C(A);return C.xpeya(B);}
 inline Symmatrix operator-(const Symmatrix &A,const Symmatrix &B)
     {Symmatrix C(A);return C.xpeya(B,-1.);}
-inline Matrix operator*(const Symmatrix &A,const Matrix &B) 
+inline Matrix operator*(const Symmatrix &A,const Matrix &B)
     {Matrix C; return genmult(A,B,C);}
 inline Matrix operator*(const Matrix &A,const Symmatrix &B)
     {Matrix C; return genmult(A,B,C);}
@@ -801,13 +810,13 @@ inline Symmatrix operator*(Real d,const 
     { return Symmatrix(A,d);}
 inline Symmatrix operator/(const Symmatrix& A,Real d)
     { return Symmatrix(A,1./d);}
-inline Symmatrix operator+(const Symmatrix& A,Real d)        
+inline Symmatrix operator+(const Symmatrix& A,Real d)
     { Symmatrix B(A); return B+=d;}
 inline Symmatrix operator+(Real d,const Symmatrix &A)
     {Symmatrix B(A); return B+=d;}
-inline Symmatrix operator-(const Symmatrix& A,Real d)        
+inline Symmatrix operator-(const Symmatrix& A,Real d)
     { Symmatrix B(A); return B-=d;}
-inline Symmatrix operator-(Real d,const Symmatrix &A)    
+inline Symmatrix operator-(Real d,const Symmatrix &A)
     { Symmatrix B(A,-1.);return B+=d;}
 
 
